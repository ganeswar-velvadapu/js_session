<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>JavaScript Essentials</title>
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.3.1/reset.min.css">
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.3.1/reveal.min.css">
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.3.1/theme/night.min.css">
	<link rel="stylesheet"
		href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.3.1/plugin/highlight/monokai.min.css">
	<style>
		:root {
			--main-bg-color: #191919;
			--main-text-color: #f5f5f5;
			--accent-color: #61dafb;
			--secondary-color: #f0db4f;
			--code-bg: #2d2d2d;
		}

		.reveal {
			font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
		}

		.reveal h1,
		.reveal h2,
		.reveal h3,
		.reveal h4 {
			font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
			color: var(--accent-color);
			text-transform: none;
			margin-bottom: 30px;
		}

		.reveal h1 {
			font-size: 2.5em;
			font-weight: 600;
		}

		.reveal h2 {
			font-size: 1.8em;
			font-weight: 500;
			color: var(--secondary-color);
		}

		.reveal h3 {
			font-size: 1.4em;
		}

		.reveal p,
		.reveal li {
			font-size: 1.1em;
			line-height: 1.5;
			margin-bottom: 0.8em;
		}

		.reveal code {
			background-color: var(--code-bg);
			padding: 0.2em 0.4em;
			border-radius: 3px;
			font-family: Consolas, Monaco, 'Andale Mono', monospace;
		}

		.reveal pre {
			box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
			border-radius: 5px;
			margin: 20px 0;
		}

		.reveal pre code {
			padding: 16px;
			line-height: 1.5;
			font-size: 0.9em;
			max-height: 400px;
		}

		.reveal section {
			height: 100%;
		}

		.reveal table {
			margin: 20px 0;
			width: 100%;
			border-collapse: collapse;
		}

		.reveal th,
		.reveal td {
			border: 1px solid #444;
			padding: 8px 12px;
			text-align: left;
		}

		.reveal th {
			background-color: #333;
			color: var(--accent-color);
		}


		.grid-2 {
			display: grid;
			grid-template-columns: 1fr 1fr;
			gap: 20px;
			margin: 20px 0;
		}

		.centered-content {
			display: flex;
			flex-direction: column;
			justify-content: center;
			align-items: center;
			height: 100%;
		}

		.js-logo {
			background-color: var(--secondary-color);
			color: #000;
			font-weight: bold;
			padding: 40px;
			font-size: 120px;
			border-radius: 20px;
			margin-bottom: 30px;
			box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
		}
	</style>
</head>

<body>
	<div class="reveal">

		<div class="slides">
			<!-- JS Part -->
			<!-- Title Slide -->
			<section>
				<div class="centered-content">
					<div class="js-logo">JS</div>
					<h1>JavaScript by Lambda IITH</h1>
				</div>
			</section>

			<!-- Table of Contents -->
			<section>
				<h2>What We'll Cover</h2>
				<div class="grid-2">
					<div>
						<ul style="font-size: 25px;">
							<li>Variables & Data Types</li>
							<li>Operators & Comparisons</li>
							<li>Arrays & Methods</li>
							<li>Objects & Methods</li>
							<li>Functions & Scopes</li>
						</ul>
					</div>
					<div>
						<ul style="font-size: 25px;">
							<li>Arrow Functions & IIFE</li>
							<li>Control Flow</li>
							<li>Loops & Iterations</li>
							<li>DOM Manipulation</li>
							<li>Asynchronous JavaScript</li>
						</ul>
					</div>
				</div>
			</section>

			<!-- Variables -->

			<section>
				<h2>Variables in JavaScript</h2>
				<div class="">
					<p>Variables are containers for storing data values.</p>
				</div>
				<p>Three ways to declare variables:</p>
				<pre><code class="javascript">// var - function scoped (older, avoid when possible)
var oldVariable = "I'm old school";

// let - block scoped (use for values that will change)
let counter = 0;

// const - block scoped (use for values that won't change)
const API_KEY = "abc123";</code></pre>
			</section>
			<section>
				<h2 class="title">Variable Scopes & Hoisting</h2>
				<div class="grid-2">
					<div>
						<h4>var</h4>
						<ul style="font-size: 25px;">
							<li>Function-scoped</li>
							<li>Can be redeclared</li>
						</ul>
					</div>
					<div>
						<h4>let & const</h4>
						<ul style="font-size: 25px;">
							<li>Block-scoped</li>
							<li>Cannot be redeclared in same scope</li>
							<li>const must be initialized and can't be reassigned</li>
						</ul>
					</div>
				</div>
				<div class="">
					<p>Best Practice: Use const by default, let when needed, avoid var</p>
				</div>
			</section>

			<!-- Data Types -->

			<section>
				<h2>JavaScript Data Types</h2>
				<p>JavaScript has 8 data types:</p>
				<div class="grid-2">
					<div>
						<h3 style="font-size:25px">Primitive Types</h3>
						<ul style="font-size: 20px;">
							<li>String</li>
							<li>Number</li>
							<li>Boolean</li>
							<li>Undefined</li>
							<li>Null</li>
							<li>Symbol</li>
							<li>BigInt</li>
						</ul>
					</div>
					<div>
						<h3 style="font-size: 25px;">Reference Type</h3>
						<ul>
							<li style="font-size: 22px;">Object
								<ul style="font-size: 20px;">
									<li>Object literals</li>
									<li>Arrays</li>
									<li>Functions</li>
									<li>Dates</li>
									<li>RegExp</li>
									<li>Map, Set, etc.</li>
								</ul>
							</li>
						</ul>
					</div>
				</div>
			</section>
			<section>
				<h2 class="title">Primitive Types Examples</h2>
				<pre><code class="javascript">// String - text data
const name = "JavaScript";

// Number - integers and floating points
const integer = 42;
const float = 3.14;

// Boolean - true/false
const isActive = true;

// Undefined - variable declared but not assigned
let future;

// Null - intentional absence of value
const empty = null;

// Symbol - unique identifier
const uniqueId = Symbol("id");

// BigInt - for large integers
const bigNumber = 9007199254740991n;</code></pre>
			</section>
			<section>
				<h2 class="title">Reference Types Example</h2>
				<pre><code class="javascript">// Object - collection of key-value pairs
const person = {
  name: "John",
  age: 30
};

// Array - ordered collection of items
const fruits = ["apple", "orange", "banana"];

// Function - callable object
function greet() {
  return "Hello!";
}
</code></pre>
			</section>
			<section>
				<h2 class="title">Checking Types</h2>
				<pre><code class="javascript">// Using typeof operator
console.log(typeof "Hello");     // "string"
console.log(typeof 42);         // "number"
console.log(typeof true);       // "boolean"
console.log(typeof undefined);  // "undefined"
console.log(typeof null);       // "object" (‚ö†Ô∏è historical bug)
console.log(typeof Symbol());   // "symbol"
console.log(typeof {});         // "object"
console.log(typeof []);         // "object" (arrays are objects)
console.log(typeof function(){}); // "function"

// For arrays, use Array.isArray()
console.log(Array.isArray([])); // true</code></pre>
			</section>


			<!-- Operators -->

			<section>
				<h2>JavaScript Operators</h2>
				<div class="">
					<p>Symbols that perform operations on operands (values and variables).</p>
				</div>
				<table style="font-size: 20px;">
					<tr>
						<th>Operator Type</th>
						<th>Examples</th>
					</tr>
					<tr>
						<td>Assignment</td>
						<td>=, +=, -=, *=, /=, %=</td>
					</tr>
					<tr>
						<td>Arithmetic</td>
						<td>+, -, *, /, %, **, ++, --</td>
					</tr>
					<tr>
						<td>Comparison</td>
						<td>==, ===, !=, !==, >, <,>=, <=< /td>
					</tr>
					<tr>
						<td>Logical</td>
						<td>&&, ||, !</td>
					</tr>
					<tr>
						<td>Bitwise</td>
						<td>&, |, ~, ^, <<,>>, >>></td>
					</tr>
					<tr></tr>
				</table>
			</section>
			<section>
				<h2 class="title">Arithmetic Operators</h2>
				<pre><code class="javascript">// Basic arithmetic
let a = 10;
let b = 3;

a + b;    // 13 (addition)
a - b;    // 7 (subtraction)
a * b;    // 30 (multiplication)
a / b;    // 3.3333... (division)
a % b;    // 1 (modulus - remainder)
a ** b;   // 1000 (exponentiation - 10^3)

// Increment/decrement
let counter = 5;
counter++;  // 5 (post-increment, returns then adds 1)
++counter;  // 7 (pre-increment, adds 1 then returns)
counter--;  // 7 (post-decrement, returns then subtracts 1)
--counter;  // 5 (pre-decrement, subtracts 1 then returns)</code></pre>
			</section>
			<section>
				<h2 class="title">Comparison Operators</h2>
				<pre><code class="javascript">// Loose equality (with type conversion)
5 == "5";      // true
0 == false;    // true
"" == 0;       // true
null == undefined; // true

// Strict equality (no type conversion)
5 === "5";     // false
0 === false;   // false

// Inequality
5 != "6";      // true
5 !== 5;       // false

// Relational
5 > 3;         // true
5 < 3;         // false
5 >= 5;        // true
5 <= 6;        // true</code></pre>
				<div class="">
					<p style="font-size: 25px;">Best Practice: Always use strict equality (===, !==) to avoid unexpected
						type conversions</p>
				</div>
			</section>
			<section>
				<h2 class="title">Logical Operators</h2>
				<pre><code class="javascript">// Logical AND (&&) - returns first falsy value or last value
true && true;    // true
true && false;   // false
"Hello" && 42;   // 42 (both truthy, returns last value)
0 && "Hello";    // 0 (first value is falsy, returns it)

// Logical OR (||) - returns first truthy value or last value
true || false;   // true
false || false;  // false
"Hello" || 42;   // "Hello" (first value is truthy, returns it)
0 || "";         // "" (both falsy, returns last value)

// Logical NOT (!) - converts to boolean and inverts
!true;           // false
!0;              // true
!!"Hello";       // true (double negation = boolean conversion)</code></pre>
			</section>




			<!-- Arrays -->

			<section>
				<h2>Arrays</h2>
				<div style="font-size: 20px;">
					<p>Ordered collections of values accessed by index (starting at 0).</p>
				</div>
				<h3 style="font-size: 25px;">Creating Arrays</h3>
				<pre><code class="javascript">// Array literal (preferred)
const fruits = ["apple", "banana", "orange"];

// Array constructor (less common)
const numbers = new Array(1, 2, 3, 4, 5);

// Empty array
const empty = [];

// Array with preset length but no values
const preset = new Array(5);  // [empty √ó 5]

// Array from other iterable
const chars = Array.from("hello");  // ["h", "e", "l", "l", "o"]
const items = Array.of(1, 2, 3);    // [1, 2, 3]</code></pre>
			</section>
			<section>
				<h2 class="title">Accessing Array Elements</h2>
				<pre><code class="javascript">const fruits = ["apple", "banana", "orange", "mango"];

// Access by index
fruits[0];                // "apple"
fruits[2];                // "orange"
fruits[fruits.length - 1]; // "mango" (last element)

// Out of bounds
fruits[10];               // undefined (no error)

// Nested arrays
const matrix = [[1, 2], [3, 4]];
matrix[0][1];             // 2

// Modifying elements
fruits[1] = "pear";       // ["apple", "pear", "orange", "mango"]

// Length property
fruits.length;            // 4

// Extend array by setting length
fruits.length = 6;        // ["apple", "pear", "orange", "mango", empty √ó 2]

// Truncate array by setting length
fruits.length = 2;        // ["apple", "pear"]</code></pre>
			</section>
			<section>
				<h2 class="title">Basic Array Methods</h2>
				<pre><code class="javascript">const fruits = ["apple", "banana", "orange"];

// Adding elements
fruits.push("mango");         // 4 (returns new length)
                              // ["apple", "banana", "orange", "mango"]
fruits.unshift("strawberry"); // 5 (returns new length)
                              // ["strawberry", "apple", "banana", "orange", "mango"]

// Removing elements
fruits.pop();                 // "mango" (returns removed element)
                              // ["strawberry", "apple", "banana", "orange"]
fruits.shift();               // "strawberry" (returns removed element)
                              // ["apple", "banana", "orange"]

// Finding elements
fruits.indexOf("banana");     // 1
fruits.includes("orange");    // true

// Combining arrays
const more = ["grape", "kiwi"];
const combined = fruits.concat(more);  // ["apple", "banana", "orange", "grape", "kiwi"]

// Extracting parts (slice does not modify original)
fruits.slice(1, 3);           // ["banana", "orange"]</code></pre>
			</section>
			<section>
				<h2 class="title">Array Methods for Transformation</h2>
				<pre><code class="javascript">const numbers = [1, 2, 3, 4, 5];

// map - transform each element (returns new array)
const doubled = numbers.map(num => num * 2);
// [2, 4, 6, 8, 10]

// filter - keep elements that pass a test (returns new array)
const evens = numbers.filter(num => num % 2 === 0);
// [2, 4]

// reduce - accumulate values (returns single value)
const sum = numbers.reduce((acc, num) => acc + num, 0);
// 15

// some - tests if any element passes (returns boolean)
const hasEven = numbers.some(num => num % 2 === 0);
// true

// every - tests if all elements pass (returns boolean)
const allPositive = numbers.every(num => num > 0);
// true</code></pre>
			</section>
			<section>
				<h2 class="title">Objects in JavaScript</h2>
				<div>
					<p style="font-size: 25px;">
						Objects are collections of <strong>key-value pairs</strong> used to group related data and
						functionality.
					</p>
					<ul style="font-size: 20px;">
						<li>Properties store data.</li>
						<li>Methods are functions stored in properties.</li>
					</ul>

					<p style="font-size: 22px; margin-top: 20px;"><strong>Example:</strong></p>
					<pre><code class="code" style="font-size: 18px;" data-trim data-noescape>
			  const car = {
				brand: "Toyota",
				start: function() {
				  console.log("Engine started");
				}
			  };
			  
			  console.log(car.brand); // Toyota
			  car.start();            // Engine started
				  </code></pre>
				</div>
			</section>


			<section>
				<h2 class="title">Object with Method</h2>
				<pre><code class="code" data-trim data-noescape>
			const person = {
			  name: "Alice",
			  age: 25,
			  greet: function() {
				console.log("Hello, " + this.name);
			  }
			};
			
			person.greet(); // Hello, Alice
				</code></pre>
				<p style="font-size: 20px;">The <code>greet()</code> function is a method of the <code>person</code>
					object.</p>
			</section>



			<section>
				<h2 class="title">Built-in Object Methods</h2>
				<pre><code class="code" data-trim data-noescape>
			const person = {
			  name: "Alice",
			  age: 25
			};
			
			console.log(Object.keys(person));   // ["name", "age"]
			console.log(Object.values(person)); // ["Alice", 25]
			console.log(Object.entries(person));// [["name", "Alice"], ["age", 25]]
				</code></pre>
				<ul style="font-size: 20px;">
					<li><code>Object.keys()</code> ‚Äì returns property names.</li>
					<li><code>Object.values()</code> ‚Äì returns property values.</li>
					<li><code>Object.entries()</code> ‚Äì returns [key, value] pairs.</li>
				</ul>
			</section>

			<section>
				<h2 class="title">Functions in JavaScript</h2>
				<div style="font-size: 30px;">
					<p>Functions are reusable blocks of code that perform a specific task.</p>
					<pre><code class="code" data-trim data-noescape>
			function greet(name) {
			  return "Hello, " + name + "!";
			}
			
			console.log(greet("Alice")); // Hello, Alice!
				  </code></pre>
					<ul>
						<li><code>function</code> keyword is used to declare a function.</li>
						<li>Parameters go inside <code>()</code>, code inside <code>{}</code>.</li>
						<li><code>return</code> sends the result back.</li>
					</ul>
				</div>
			</section>

			<section>
				<h2 class="title">Function Scope</h2>
				<div class="content">
					<p>Scope defines where variables can be accessed from.</p>
					<pre><code class="code" data-trim data-noescape>
			function testScope() {
			  let inside = "I am inside!";
			  console.log(inside);
			}
			
			testScope();
			// console.log(inside); // ‚ùå Error: inside is not defined
				  </code></pre>
					<p><strong>Variables declared inside a function</strong> are not accessible outside.</p>
				</div>
			</section>

			<section>
				<h2 class="title">Block vs Function Scope</h2>
				<div class="grid-2" style="font-size: 20px;">
					<div>
						<h4><code>let</code> and <code>const</code></h4>
						<ul>
							<li>Block-scoped</li>
							<li>Only exist within <code>{ }</code> block</li>
						</ul>
					</div>
					<div>
						<h4><code>var</code></h4>
						<ul>
							<li>Function-scoped</li>
							<li>Accessible anywhere in the function</li>
						</ul>
					</div>
				</div>
				<pre><code class="code" data-trim data-noescape>
			if (true) {
			  let a = 10;
			  var b = 20;
			}
			
			// console.log(a); // ‚ùå Error
			console.log(b);   // ‚úÖ 20
				</code></pre>
			</section>

			<!-- Slide 1: Intro to Arrow Functions -->
			<section>
				<h2 class="title">Arrow Functions</h2>
				<div class="content">
					<p>Arrow functions are a shorter way to write function expressions.</p>
					<pre><code class="code" data-trim data-noescape>
// Regular function
function add(a, b) {
  return a + b;
}

// Arrow function
const add = (a, b) => a + b;
      </code></pre>
					<p>They're great for short, inline functions.</p>
				</div>
			</section>

			<!-- Slide 2: More Arrow Function Examples -->
			<section>
				<h2 class="title">Arrow Function Syntax</h2>
				<ul class="content">
					<li><code>() => { }</code> ‚Äî no parameters</li>
					<li><code>x => x * 2</code> ‚Äî single parameter, implicit return</li>
					<li><code>(a, b) => a + b</code> ‚Äî multiple parameters</li>
				</ul>
				<pre><code class="code" data-trim data-noescape>
const greet = name => `Hello, ${name}`;
console.log(greet("Alice")); // Hello, Alice
    </code></pre>
			</section>

			<!-- Slide 3: IIFE (Immediately Invoked Function Expression) -->
			<section>
				<h2 class="title">IIFE</h2>
				<div class="content">
					<p>IIFE stands for <strong>Immediately Invoked Function Expression</strong>.</p>
					<p>It's a function that runs as soon as it's defined.</p>
					<pre><code class="code" data-trim data-noescape>
(function() {
  console.log("I run immediately!");
})();

// Or with arrow function:
(() => {
  console.log("Arrow IIFE!");
})();
      </code></pre>
				</div>
			</section>

			<!-- Slide 4: Arrow Function vs Regular Function -->
			<section>
				<h2 class="title">Arrow vs Regular Function</h2>
				<div class="grid-2" style="font-size: 20px;">
					<div>
						<h4>Regular Function</h4>
						<ul class="content">
							<li>Has its own <code>this</code> context</li>
							<li>Can be used as constructors</li>
							<li>Can be hoisted</li>
						</ul>
					</div>
					<div>
						<h4>Arrow Function</h4>
						<ul class="content">
							<li><strong>No</strong> own <code>this</code> (lexical binding)</li>
							<li>Can't be used as constructors</li>
							<li>Not hoisted</li>
						</ul>
					</div>
				</div>
				<p class="content" style="margin-top: 1em;"><strong>Use arrow functions for:</strong> short callbacks,
					array methods, concise expressions.</p>
			</section>

			<section>
				<h2 class="title">Control Flow in JavaScript</h2>
				<div class="content">
					<p>Control flow determines the order in which code is executed in a program.</p>
					<ul>
						<li><strong>if / else if / else</strong></li>
						<li><strong>switch</strong></li>
						<li><strong>Loops:</strong> for, while, do...while</li>
						<li><strong>break</strong> & <strong>continue</strong></li>
					</ul>
				</div>
			</section>

			<!-- Slide 2: if / else -->
			<section>
				<h2 class="title">if / else</h2>
				<pre><code class="code" data-trim data-noescape>
			const score = 85;
			
			if (score >= 90) {
			  console.log("Grade: A");
			} else if (score >= 75) {
			  console.log("Grade: B");
			} else {
			  console.log("Grade: C");
			}
				</code></pre>
				<p class="content">Use <strong>if-else</strong> to execute code based on conditions.</p>
			</section>

			<!-- Slide 3: switch -->
			<section>
				<h2 class="title">Switch Statement</h2>
				<pre><code class="code" data-trim data-noescape>
			const fruit = "apple";
			
			switch (fruit) {
			  case "apple":
				console.log("It's an apple!");
				break;
			  case "banana":
				console.log("It's a banana!");
				break;
			  default:
				console.log("Unknown fruit");
			}
				</code></pre>
				<p class="content">Use <strong>switch</strong> for multiple exact match conditions.</p>
			</section>


			<!-- Slide: Title -->
			<section>
				<h2 class="title">Loops & Iterations in JavaScript</h2>
				<p class="content">Control structures for executing code repeatedly with conditions.</p>
			</section>

			<!-- Slide: for loop -->
			<section>
				<h2 class="title">for Loop</h2>
				<p class="content">Executes a block a specific number of times.</p>
				<pre><code class="code" data-trim data-noescape>
  for (let i = 0; i < 3; i++) {
	console.log("For loop:", i);
  }
	</code></pre>
			</section>

			<!-- Slide: while loop -->
			<section>
				<h2 class="title">while Loop</h2>
				<p class="content">Runs while the condition is true.</p>
				<pre><code class="code" data-trim data-noescape>
  let i = 0;
  while (i < 3) {
	console.log("While:", i);
	i++;
  }
	</code></pre>
			</section>

			<!-- Slide: do...while loop -->
			<section>
				<h2 class="title">do...while Loop</h2>
				<p class="content">Runs at least once before checking condition.</p>
				<pre><code class="code" data-trim data-noescape>
  let j = 0;
  do {
	console.log("Do while:", j);
	j++;
  } while (j < 3);
	</code></pre>
			</section>

			<!-- Slide: break & continue -->
			<section>
				<h2 class="title">break & continue</h2>
				<ul class="content">
					<li><strong>break</strong>: Exits the loop early</li>
					<li><strong>continue</strong>: Skips to the next iteration</li>
				</ul>
				<pre><code class="code" data-trim data-noescape>
  for (let x = 0; x < 5; x++) {
	if (x === 2) continue;
	if (x === 4) break;
	console.log("Loop x:", x);
  }
  // Output: 0 1 3
	</code></pre>
			</section>

			<!-- Slide: forEach -->
			<section>
				<h2 class="title">forEach</h2>
				<p class="content">Array method that runs a function for each element.</p>
				<pre><code class="code" data-trim data-noescape>
  ["a", "b", "c"].forEach((val, idx) => {
	console.log(idx, val);
  });
	</code></pre>
			</section>

			<!-- Slide: for...of -->
			<section>
				<h2 class="title">for...of</h2>
				<p class="content">Loops through iterable values (e.g., arrays).</p>
				<pre><code class="code" data-trim data-noescape>
  for (const letter of ["x", "y", "z"]) {
	console.log(letter);
  }
	</code></pre>
			</section>

			<!-- Slide: map -->
			<section>
				<h2 class="title">map()</h2>
				<p class="content">Creates a new array by transforming each item.</p>
				<pre><code class="code" data-trim data-noescape>
  const nums = [1, 2, 3];
  const squares = nums.map(n => n * n);
  console.log(squares); // [1, 4, 9]
	</code></pre>
			</section>

			<!-- Slide: When to use what? -->
			<section>
				<h2 class="title">Which Loop to Use?</h2>
				<ul style="font-size: 20px;">
					<li><code>for</code>: When you need index control or count-based iteration</li>
					<li><code>while</code>: When looping condition isn't index-based</li>
					<li><code>do...while</code>: When the loop must run at least once</li>
					<li><code>map</code>: To transform arrays into new arrays</li>
					<li><code>forEach</code>: To perform an action on each item (no return)</li>
					<li><code>for...of</code>: Clean syntax for looping over iterable values</li>
				</ul>
			</section>

			<section>
				<h2 class="title">What is the DOM?</h2>
				<div class="content">
					<p style="font-size: 22px;">
						The <strong>DOM (Document Object Model)</strong> is a programming interface that represents a
						web page as a tree structure of objects.
					</p>
					<ul style="font-size: 20px;">
						<li>Each element becomes a <code>node</code> in the tree</li>
						<li>JavaScript can access and modify the DOM dynamically</li>
					</ul>
					<pre><code class="code" data-trim data-noescape>
			  <!-- HTML -->
			  <div id="box">Hello</div>
				  </code></pre>
					<pre><code class="code" data-trim data-noescape>
			  // JS
			  const box = document.getElementById("box");
			  box.textContent = "Hi there!";
				  </code></pre>
				</div>
			</section>
			<section>
				<h2 class="title">Selecting DOM Elements</h2>
				<div class="content">
					<p style="font-size: 22px;">We can access elements using built-in JS methods:</p>
					<ul style="font-size: 20px;">
						<li><code>document.getElementById("id")</code></li>
						<li><code>document.querySelector(".class" or "tag")</code></li>
						<li><code>document.querySelectorAll("selector")</code> ‚Äî returns a NodeList</li>
					</ul>
					<pre><code class="code" data-trim data-noescape>
			  const title = document.querySelector("h1");
			  const items = document.querySelectorAll(".item");
				  </code></pre>
				</div>
			</section>

			<section>
				<h2 class="title">Manipulating Content & Style</h2>
				<div class="content">
					<ul style="font-size: 20px;">
						<li><code>element.textContent</code> ‚Äì Changes text</li>
						<li><code>element.innerHTML</code> ‚Äì Inserts HTML</li>
						<li><code>element.style</code> ‚Äì Applies inline styles</li>
					</ul>
					<pre><code class="code" data-trim data-noescape>
			  const box = document.getElementById("box");
			  box.textContent = "Updated!";
			  box.style.color = "yellow";
			  box.style.backgroundColor = "black";
				  </code></pre>
				</div>
			</section>
			<section>
				<h2 class="title">Creating & Adding Elements</h2>
				<div class="content">
					<p style="font-size: 22px;">We can dynamically build new elements and insert them into the DOM.</p>
					<pre><code class="code" data-trim data-noescape>
			  const newItem = document.createElement("li");
			  newItem.textContent = "New Item";
			  
			  const list = document.querySelector("ul");
			  list.appendChild(newItem);
				  </code></pre>
					<ul style="font-size: 20px;">
						<li><code>createElement()</code> ‚Äì makes a new element</li>
						<li><code>appendChild()</code> ‚Äì inserts into the DOM</li>
					</ul>
				</div>
			</section>
			<section>
				<h2 class="title">Event Handling</h2>
				<div class="content">
					<p style="font-size: 22px;">We can add interactivity using event listeners.</p>
					<pre><code class="code" data-trim data-noescape>
			  const button = document.querySelector("button");
			  
			  button.addEventListener("click", () => {
				alert("Button clicked!");
			  });
				  </code></pre>
					<ul style="font-size: 20px;">
						<li><code>addEventListener()</code> attaches a handler</li>
						<li>Can respond to clicks, inputs, key presses, etc.</li>
						<li>This is how we make pages dynamic!</li>
					</ul>
				</div>
			</section>

			<section>
				<h2 class="title">Asynchronous JavaScript</h2>
				<div class="content">
					<p style="font-size: 22px;">
						JavaScript is <strong>single-threaded</strong>, but we often need to perform tasks like:
					</p>
					<ul style="font-size: 20px;">
						<li>Fetching data from APIs</li>
						<li>Waiting for user actions</li>
						<li>Handling timeouts</li>
					</ul>
					<p style="margin-top: 1em; font-size: 20px;">
						To avoid blocking the UI, we use <strong>asynchronous programming</strong> techniques.
					</p>
				</div>
			</section>

			<section>
				<h2 class="title">setTimeout & setInterval</h2>
				<div class="content">
					<p style="font-size: 20px;">
						JavaScript provides <code>setTimeout</code> and <code>setInterval</code> to schedule code for
						later execution.
					</p>
					<ul style="font-size: 18px;">
						<li><strong>setTimeout(fn, delay)</strong>: runs once after delay (in ms)</li>
						<li><strong>setInterval(fn, delay)</strong>: runs repeatedly every delay</li>
					</ul>

					<pre><code class="code" data-trim data-noescape>
			  // Runs after 2 seconds
			  setTimeout(() => {
				console.log("Hello after 2 seconds");
			  }, 2000);
			  
			  // Repeats every 1 second
			  setInterval(() => {
				console.log("Tick");
			  }, 1000);
				  </code></pre>
				</div>
			</section>
			<section>
				<h2 class="title">Callback Hell üòµ</h2>
				<div class="content">
					<p style="font-size: 20px;">Using multiple nested <code>setTimeout</code>s leads to what‚Äôs called:
					</p>
					<p style="font-weight: bold; color: yellow; font-size: 22px;">"Pyramid of Doom"</p>
					<pre><code class="code" data-trim data-noescape>
			  setTimeout(() => {
				console.log("Step 1");
				setTimeout(() => {
				  console.log("Step 2");
				  setTimeout(() => {
					console.log("Step 3");
					setTimeout(() => {
					  console.log("All steps done!");
					}, 1000);
				  }, 1000);
				}, 1000);
			  }, 1000);
				  </code></pre>
					<p style="font-size: 18px;">Hard to read, debug, and maintain. We need something better.</p>
				</div>
			</section>

			<section>
				<h2 class="title">Promises üß©</h2>
				<div class="content">
					<p style="font-size: 20px;">A <strong>Promise</strong> is an object that represents the eventual
						result of an async operation.</p>
					<ul style="font-size: 18px;">
						<li><code>pending</code> ‚Üí initial state</li>
						<li><code>fulfilled</code> ‚Üí successful result</li>
						<li><code>rejected</code> ‚Üí failed result</li>
					</ul>
					<pre><code class="code" data-trim data-noescape>
			  const task = new Promise((resolve, reject) => {
				setTimeout(() => resolve("Done!"), 1000);
			  });
			  
			  task.then(result => console.log(result));
				  </code></pre>
				</div>
			</section>

			<section>
				<h2 class="title">Chaining Promises</h2>
				<div class="content">
					<p style="font-size: 20px;">We can chain multiple asynchronous operations using
						<code>.then()</code>:
					</p>
					<pre><code class="code" data-trim data-noescape>
doTask1()
  .then(result1 => doTask2(result1))
  .then(result2 => doTask3(result2))
  .then(final => console.log(final))
  .catch(error => console.error(error));
    </code></pre>
					<p style="font-size: 18px;">Better than callback hell, but can still get messy.</p>
				</div>
			</section>

			<section>
				<h2 class="title">Async / Await</h2>
				<div class="content">
					<p style="font-size: 20px;">
						<code>async</code> / <code>await</code> makes async code look like sync code.
					</p>
					<pre><code class="code" data-trim data-noescape>
			  async function runTasks() {
				try {
				  const result1 = await doTask1();
				  const result2 = await doTask2(result1);
				  console.log(result2);
				} catch (err) {
				  console.error(err);
				}
			  }
			  runTasks();
				  </code></pre>
					<p style="font-size: 18px;">Clean, readable, and easier to debug!</p>
				</div>
			</section>

			<section>
				<h2 class="title">Async JS: Summary</h2>
				<div class="content">
					<ul style="font-size: 20px;">
						<li><strong>Callbacks</strong>: first approach, can get messy</li>
						<li><strong>Promises</strong>: better structure with chaining</li>
						<li><strong>Async/Await</strong>: cleanest syntax, easy to follow</li>
					</ul>
					<p style="font-size: 18px; margin-top: 1em;">
						All of these help JavaScript handle time-based & async events without blocking the main thread.
					</p>
					<p style="font-size: 20px; font-weight: bold; color: yellow;">React apps rely heavily on async/await
						and promises (especially for API calls).</p>
				</div>
			</section>


			<!-- React Part -->

			<section>
				<h2 class="centered-content" style="font-size: 100px;">React</h2>
			</section>

			<section>
				<h2 class="title">What is React?</h2>
				<div class="content">
					<p style="font-size: 22px;">
						React is a <strong>JavaScript library</strong> for building <strong>user interfaces</strong>,
						developed by Facebook.
					</p>
					<ul style="font-size: 20px;">
						<li>Component-based architecture</li>
						<li>Declarative UI</li>
						<li>Fast and efficient updates via <strong>Virtual DOM</strong></li>
					</ul>
				</div>
			</section>

			<section>
				<h2 class="title">JSX: JavaScript + HTML</h2>
				<div class="content">
					<p style="font-size: 22px;">
						React uses <strong>JSX</strong>, a syntax extension that looks like HTML, but is written in
						JavaScript.
					</p>
					<pre><code class="code" data-trim data-noescape>
			  const element = &lt;h1&gt;Hello, world!&lt;/h1&gt;;
			  ReactDOM.render(element, document.getElementById('root'));
				  </code></pre>
					<p style="font-size: 18px;">JSX is not required, but it makes code more readable and expressive.</p>
				</div>
			</section>

			<section>
				<h2 class="title">JSX is Compiled by Babel</h2>
				<div class="content">
					<p style="font-size: 22px;">
						Browsers don‚Äôt understand JSX directly. It‚Äôs compiled to standard JavaScript using
						<strong>Babel</strong>.
					</p>
					<pre><code class="code" data-trim data-noescape>
			  const element = &lt;h1&gt;Hello&lt;/h1&gt;;
			  // Compiled to:
			  const element = React.createElement("h1", null, "Hello");
				  </code></pre>
					<p style="font-size: 18px;">Babel is used behind the scenes by tools like Vite, Webpack, etc.</p>
				</div>
			</section>

			<section>
				<h2 class="title">Virtual DOM vs Real DOM</h2>
				<div class="content">
					<ul style="font-size: 20px;">
						<li><strong>Real DOM</strong> updates are slow (especially for large UIs)</li>
						<li><strong>Virtual DOM</strong> is an in-memory copy React uses to detect changes efficiently
						</li>
						<li>React updates only the changed parts of the actual DOM</li>
					</ul>
					<p style="margin-top: 1em; font-size: 18px;"><strong>Result:</strong> Faster rendering and better
						performance</p>
				</div>
			</section>
			<section>
				<h2 class="title">How React Renders Your App</h2>
				<div class="content">
					<pre><code class="code" data-trim data-noescape>
			  // index.html
			  &lt;body&gt;
				&lt;div id="root"&gt;&lt;/div&gt;
			  &lt;/body&gt;
				  </code></pre>
					<pre><code class="code" data-trim data-noescape>
			  // main.jsx
			  import React from 'react';
			  import ReactDOM from 'react-dom/client';
			  import App from './App';
			  
			  ReactDOM.createRoot(document.getElementById('root')).render(
				&lt;React.StrictMode&gt;
				  &lt;App /&gt;
				&lt;/React.StrictMode&gt;
			  );
				  </code></pre>
					<p style="font-size: 18px;">React replaces <code>&lt;div id="root"&gt;</code> with
						the rendered UI from <code>App.jsx</code>.</p>
				</div>
			</section>

			<section>
				<h2 class="title">Components & Props</h2>
				<div class="content">
					<p style="font-size: 22px;">Everything in React is a <strong>component</strong>.</p>
					<pre><code class="code" data-trim data-noescape>
			  function Welcome(props) {
				return &lt;h1&gt;Hello, {props.name}!&lt;/h1&gt;;
			  }
			  
			  &lt;Welcome name="Alice" /&gt;
				  </code></pre>
					<ul style="font-size: 20px;">
						<li><strong>Components</strong> are reusable pieces of UI</li>
						<li><strong>Props</strong> are how you pass data to components</li>
					</ul>
				</div>
			</section>

			<section>
				<h2 class="title">State in React</h2>
				<div class="content">
					<p style="font-size: 22px;">
						<strong>State</strong> is data that changes over time and controls component behavior.
					</p>
					<pre><code class="code" data-trim data-noescape>
			  import { useState } from "react";
			  
			  function Counter() {
				const [count, setCount] = useState(0);
				
				return (
				  &lt;div&gt;
					&lt;p&gt;Count: {count}&lt;/p&gt;
					&lt;button onClick={() => setCount(count + 1)}&gt;Add&lt;/button&gt;
				  &lt;/div&gt;
				);
			  }
				  </code></pre>
					<p style="font-size: 18px;">React automatically re-renders the UI when state changes.</p>
				</div>
			</section>


		</div>



	</div>
	<script src="dist/reveal.js">
	</script>
	<script src="plugin/notes/notes.js"></script>
	<script src="plugin/markdown/markdown.js"></script>
	<script src="plugin/highlight/highlight.js"></script>
	<script> Reveal.initialize({ hash: true, plugins: [RevealMarkdown, RevealHighlight, RevealNotes] }); </script>

</body>

</html>